<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>bpw2_classify3b</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-01-02">
<meta name="DC.source" content="bpw2_classify3b.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> R = bpw2_classify3b(matfile)
<span class="comment">% As before, but do cross-validation following https://www.mathworks.com/help/stats/fitcecoc.html.</span>

<span class="comment">% After running, do this to examine the result R.</span>
<span class="comment">% load('/local/matlab/bpstress/bpw2_classify3c1.mat')</span>

<span class="comment">% Initialize the result.</span>
R = {};
<span class="comment">% The initial part of this is like bpw2_stat1.</span>
<span class="keyword">if</span> nargin &lt; 1
    <span class="comment">%matfile = '/local/matlab/Kaldi-alignments-matlab/data-bpn/tab4-sample.mat'; % Made with token_data_bpw2.</span>
    matfile = <span class="string">'/local/matlab/bpstress/data-bpn/tab4.mat'</span>; <span class="comment">% All the data, 15388 bisyllables</span>
    savename = <span class="string">'/local/matlab/bpstress/data-bpn/bpw2_classify3b'</span>;
<span class="keyword">end</span>



<span class="comment">% Load sets L to a structure. It has to be initialized first.</span>
L = 0;
load(matfile);

<span class="comment">% Initialize the result.</span>
R = {};

<span class="comment">% Scale for combining the two weights.</span>
acoustic_scale = 0.083333;
<span class="comment">% Then combine by this formula, see</span>
<span class="comment">% /projects/speech/sys/kaldi-master/egs/bp_ldcWestPoint/bpw2/exp/u1/decode_word_1/tab-min.awk</span>
<span class="comment">% weight = weight1 +  acoustic_scale * weight2;</span>

<span class="comment">% Duration in frames</span>
D = cellfun(@sum,L.phonedur)';

<span class="comment">% Combined weights</span>
W1 = cellfun(@(x,y) x + acoustic_scale * y,L.weight1,L.weight2,<span class="string">'UniformOutput'</span>,false)';

<span class="comment">% Combined weights scaled down by duration.</span>
<span class="comment">% This produces weights in the range 7.0 to 9.5.</span>
W2 = cellfun(@(x,y) x ./ y,W1,num2cell(D),<span class="string">'UniformOutput'</span>,false);

<span class="comment">% This part is like bpw2_stat3.m</span>
<span class="comment">% Logical indices of ultimate-stressed triplus-syllables</span>
<span class="comment">% and penultimate-stressed triplus, and</span>
<span class="comment">% ante-penultimate tripus</span>
U31 = L.syl &gt; 2 &amp; L.cstress == 1;
U32 = L.syl &gt; 2 &amp; L.cstress == 2;
U33 = L.syl &gt; 2 &amp; L.cstress == 3;

<span class="comment">% Logical indices of all tokens with three or more syllables</span>
U3 = L.syl &gt; 2;

<span class="comment">% Indices that are 1 in U3, for mapping back to L.</span>
I3 = find(U3);

<span class="comment">% Corresponding matrices of weights, with varying number of readings.</span>
<span class="comment">% Cell3mat can't be applied.</span>
U31wv = W2(U31);  <span class="comment">% 1584 3</span>
U32wv = W2(U32);  <span class="comment">% 7331 3</span>
U33wv = W2(U33);  <span class="comment">%  336 3</span>
U3wv = W2(U3);

<span class="comment">% Select three columns and map to matrix</span>
<span class="comment">% Each token is characterized by its weights in three readings.</span>
U31w = cell2mat(cellfun(@(x) [x(1),x(2),x(3)], U31wv,<span class="string">'UniformOutput'</span>,false));
U32w = cell2mat(cellfun(@(x) [x(1),x(2),x(3)], U32wv,<span class="string">'UniformOutput'</span>,false));
U33w = cell2mat(cellfun(@(x) [x(1),x(2),x(3)], U33wv,<span class="string">'UniformOutput'</span>,false));
U3w = cell2mat(cellfun(@(x) [x(1),x(2),x(3)], U3wv,<span class="string">'UniformOutput'</span>,false));

<span class="comment">%%%%%%%% Duration %%%%%%%%</span>
<span class="comment">% Vowel durations. L.voweldur is not of uniform length,</span>
<span class="comment">% and the vowels need to count from the end. This is</span>
<span class="comment">% adjusted by the anonymous function.</span>
<span class="comment">% We assume L.voweldur has vowel lengths in time order.</span>
U31d = cell2mat(cellfun(@(x) [x(length(x)),x(length(x)-1),x(length(x)-2)], L.voweldur(U31)',<span class="string">'UniformOutput'</span>,false));
U32d = cell2mat(cellfun(@(x) [x(length(x)),x(length(x)-1),x(length(x)-2)], L.voweldur(U32)',<span class="string">'UniformOutput'</span>,false));
U33d = cell2mat(cellfun(@(x) [x(length(x)),x(length(x)-1),x(length(x)-2)], L.voweldur(U33)',<span class="string">'UniformOutput'</span>,false));
U3d = cell2mat(cellfun(@(x) [x(length(x)),x(length(x)-1),x(length(x)-2)], L.voweldur(U3)',<span class="string">'UniformOutput'</span>,false));

<span class="comment">% Feature matrix, with six colums. Row indices are items.</span>
X = [U3w,U3d];


<span class="comment">% 1 indicating final stress</span>
<span class="comment">% 2 penultimate stress</span>
<span class="comment">% 3 antepenultimate stress.</span>
Y = U31 + U32 * 2 + U33 * 3;
Y = Y(U3);


<span class="comment">% Save the data</span>
R.X = X;
R.Y = Y;

dim = length(X(:,1));
R.dim = dim;

<span class="comment">% Fit 3-class svm using just weights, just durations</span>
<span class="comment">% and both. Durations help a bit.</span>

R.svm1 = fitcecoc(X(:,1:3),Y); <span class="comment">% Cepstral weight</span>
R.svm2 = fitcecoc(X(:,4:6),Y); <span class="comment">% Duration</span>
R.svm3 = fitcecoc(X,Y);        <span class="comment">% Both</span>



<span class="comment">% Evaluate on training data.</span>
<span class="comment">% resubLoss(R.svm1) % 0.0626  weights</span>
<span class="comment">% resubLoss(R.svm2) % 0.2101  durations</span>
<span class="comment">% resubLoss(R.svm3) % 0.0507  both</span>
disp(1);

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%</span>
<span class="comment">%  Crossvalidate following</span>
<span class="comment">%  https://www.mathworks.com/help/stats/fitcecoc.html.</span>

<span class="comment">% Template</span>
t1 = templateSVM(<span class="string">'Standardize'</span>,1);
t2 = templateSVM(<span class="string">'Standardize'</span>,1);
t3 = templateSVM(<span class="string">'Standardize'</span>,1);

<span class="comment">% Train the ECOC classifier</span>

<span class="comment">%mdl1 = fitcecoc(X(:,1:3),Y,'Learners',t1);</span>
<span class="comment">%mdl2 = fitcecoc(X(:,4:6),Y,'Learners',t2);</span>
<span class="comment">%mdl3 = fitcecoc(X,Y,'Learners',t3);</span>

<span class="comment">% Thu Nov 22 09:29:01 EST 2018</span>
<span class="comment">% The prior can be 'empirical' (default) or 'uniform', see https://www.mathworks.com/help/stats/fitcecoc.html</span>
R.mdl1 = fitcecoc(X(:,1:3),Y,<span class="string">'Learners'</span>,t1,<span class="string">'Prior'</span>,<span class="string">'empirical'</span>);
R.mdl2 = fitcecoc(X(:,4:6),Y,<span class="string">'Learners'</span>,t2,<span class="string">'Prior'</span>,<span class="string">'empirical'</span>);
R.mdl3 = fitcecoc(X,Y,<span class="string">'Learners'</span>,t3,<span class="string">'Prior'</span>,<span class="string">'empirical'</span>);

<span class="comment">% Cross-validate Mdl using 10-fold cross-validation.</span>

R.cmdl1 = crossval(R.mdl1);
R.cmdl2 = crossval(R.mdl2);
R.cmdl3 = crossval(R.mdl3);

<span class="comment">% The following values were obtained on Jan 2, 2024</span>
<span class="comment">%                           basic   uniform</span>
R.loss1 = kfoldLoss(R.cmdl1) <span class="comment">%  0.0556  0.0753</span>
R.loss2 = kfoldLoss(R.cmdl2) <span class="comment">%  0.2101  0.3465</span>
R.loss3 = kfoldLoss(R.cmdl3) <span class="comment">%  0.0461  0.0582</span>

<span class="comment">% What is the major-class baseline? Is basic weight-only any better?</span>

<span class="comment">% Save R</span>
<span class="comment">% To see R,</span>
<span class="comment">%   load('/local/matlab/bpstress/bpw2_classify3c1.mat')</span>
save(savename,<span class="string">'R'</span>);

disp(1);

<span class="comment">% Parse a line into a key and a vector of int.</span>
<span class="keyword">function</span> [key,a] = parse_alignment(line)
    key = sscanf(line,<span class="string">'%s'</span>,1);
    [~,klen] =  size(key);
    [~,llen] = size(line);
    line = line((klen+1):llen);
    a = sscanf(line,<span class="string">'%d'</span>)';
<span class="keyword">end</span>

<span class="comment">% Parse a line from the table.</span>
<span class="comment">% The input line looks like this.</span>
<span class="comment">% f58br08b11k1-s087-2	abacaxi	abacaxi_U411	4	1	1	4.45933 4.46457 4.43014 4.40614	5115.16 5122.39 5166.43 5153.47	362_364_3</span>
<span class="comment">% uid                   wf1     wf2             syl cit dec [w1] [w2]</span>
<span class="comment">%   bns04_st1921_trn 1 12 ; 6 7 ; 143 3 ; 50 8 ; 60 3 ; 143 4 ; 146 13</span>
<span class="keyword">function</span> [uid,word_form1,word_form2,syl_count,citation_stress,decode_stress,weight1,weight2] = parse_line(line)
    part = strsplit(line,<span class="string">'\t'</span>);
    uid = part{1};
    word_form1 = part{2};
    word_form2 = part{3};
    syl_count = str2num(part{4});
    citation_stress = str2num(part{5});
    decode_stress = str2num(part{6});
    weight1 = str2num(part{7});
    weight2 = str2num(part{8});
<span class="keyword">end</span>

<span class="comment">% Result of 'OptimizeHyperparameters','all'</span>
<span class="comment">% Best estimated feasible point (according to models):</span>
<span class="comment">%    BoxConstraint    KernelScale    KernelFunction    PolynomialOrder    Standardize</span>
<span class="comment">%    _____________    ___________    ______________    _______________    ___________</span>
<span class="comment">%</span>
<span class="comment">%       6.9424            NaN          polynomial             2              true</span>
<span class="comment">%</span>
<span class="comment">%Estimated objective function value = 0.082355</span>
<span class="comment">%Estimated function evaluation time = 0.48633</span>

<span class="comment">% 0.0846 weight</span>
<span class="comment">% 0.3035 duration</span>
<span class="comment">% 0.0871 both--it's a bit worse</span>

<span class="keyword">end</span>
</pre>
<pre class="codeoutput">     1


R = 

  struct with fields:

        X: [9281&times;6 double]
        Y: [9281&times;1 double]
      dim: 9281
     svm1: [1&times;1 ClassificationECOC]
     svm2: [1&times;1 ClassificationECOC]
     svm3: [1&times;1 ClassificationECOC]
     mdl1: [1&times;1 ClassificationECOC]
     mdl2: [1&times;1 ClassificationECOC]
     mdl3: [1&times;1 ClassificationECOC]
    cmdl1: [1&times;1 classreg.learning.partition.ClassificationPartitionedECOC]
    cmdl2: [1&times;1 classreg.learning.partition.ClassificationPartitionedECOC]
    cmdl3: [1&times;1 classreg.learning.partition.ClassificationPartitionedECOC]
    loss1: 0.0560


R = 

  struct with fields:

        X: [9281&times;6 double]
        Y: [9281&times;1 double]
      dim: 9281
     svm1: [1&times;1 ClassificationECOC]
     svm2: [1&times;1 ClassificationECOC]
     svm3: [1&times;1 ClassificationECOC]
     mdl1: [1&times;1 ClassificationECOC]
     mdl2: [1&times;1 ClassificationECOC]
     mdl3: [1&times;1 ClassificationECOC]
    cmdl1: [1&times;1 classreg.learning.partition.ClassificationPartitionedECOC]
    cmdl2: [1&times;1 classreg.learning.partition.ClassificationPartitionedECOC]
    cmdl3: [1&times;1 classreg.learning.partition.ClassificationPartitionedECOC]
    loss1: 0.0560
    loss2: 0.2101


R = 

  struct with fields:

        X: [9281&times;6 double]
        Y: [9281&times;1 double]
      dim: 9281
     svm1: [1&times;1 ClassificationECOC]
     svm2: [1&times;1 ClassificationECOC]
     svm3: [1&times;1 ClassificationECOC]
     mdl1: [1&times;1 ClassificationECOC]
     mdl2: [1&times;1 ClassificationECOC]
     mdl3: [1&times;1 ClassificationECOC]
    cmdl1: [1&times;1 classreg.learning.partition.ClassificationPartitionedECOC]
    cmdl2: [1&times;1 classreg.learning.partition.ClassificationPartitionedECOC]
    cmdl3: [1&times;1 classreg.learning.partition.ClassificationPartitionedECOC]
    loss1: 0.0560
    loss2: 0.2101
    loss3: 0.0462

     1


ans = 

  struct with fields:

        X: [9281&times;6 double]
        Y: [9281&times;1 double]
      dim: 9281
     svm1: [1&times;1 ClassificationECOC]
     svm2: [1&times;1 ClassificationECOC]
     svm3: [1&times;1 ClassificationECOC]
     mdl1: [1&times;1 ClassificationECOC]
     mdl2: [1&times;1 ClassificationECOC]
     mdl3: [1&times;1 ClassificationECOC]
    cmdl1: [1&times;1 classreg.learning.partition.ClassificationPartitionedECOC]
    cmdl2: [1&times;1 classreg.learning.partition.ClassificationPartitionedECOC]
    cmdl3: [1&times;1 classreg.learning.partition.ClassificationPartitionedECOC]
    loss1: 0.0560
    loss2: 0.2101
    loss3: 0.0462

</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
function R = bpw2_classify3b(matfile)
% As before, but do cross-validation following https://www.mathworks.com/help/stats/fitcecoc.html.

% After running, do this to examine the result R.
% load('/local/matlab/bpstress/bpw2_classify3c1.mat')

% Initialize the result.
R = {};
% The initial part of this is like bpw2_stat1.
if nargin < 1
    %matfile = '/local/matlab/Kaldi-alignments-matlab/data-bpn/tab4-sample.mat'; % Made with token_data_bpw2.
    matfile = '/local/matlab/bpstress/data-bpn/tab4.mat'; % All the data, 15388 bisyllables
    savename = '/local/matlab/bpstress/data-bpn/bpw2_classify3b';
end



% Load sets L to a structure. It has to be initialized first.
L = 0;
load(matfile);

% Initialize the result.
R = {};

% Scale for combining the two weights.
acoustic_scale = 0.083333;
% Then combine by this formula, see
% /projects/speech/sys/kaldi-master/egs/bp_ldcWestPoint/bpw2/exp/u1/decode_word_1/tab-min.awk
% weight = weight1 +  acoustic_scale * weight2;

% Duration in frames
D = cellfun(@sum,L.phonedur)';

% Combined weights
W1 = cellfun(@(x,y) x + acoustic_scale * y,L.weight1,L.weight2,'UniformOutput',false)';

% Combined weights scaled down by duration.
% This produces weights in the range 7.0 to 9.5.
W2 = cellfun(@(x,y) x ./ y,W1,num2cell(D),'UniformOutput',false);

% This part is like bpw2_stat3.m
% Logical indices of ultimate-stressed triplus-syllables
% and penultimate-stressed triplus, and
% ante-penultimate tripus
U31 = L.syl > 2 & L.cstress == 1;
U32 = L.syl > 2 & L.cstress == 2;
U33 = L.syl > 2 & L.cstress == 3;

% Logical indices of all tokens with three or more syllables
U3 = L.syl > 2;

% Indices that are 1 in U3, for mapping back to L.
I3 = find(U3);

% Corresponding matrices of weights, with varying number of readings.
% Cell3mat can't be applied.
U31wv = W2(U31);  % 1584 3
U32wv = W2(U32);  % 7331 3
U33wv = W2(U33);  %  336 3
U3wv = W2(U3);

% Select three columns and map to matrix
% Each token is characterized by its weights in three readings.
U31w = cell2mat(cellfun(@(x) [x(1),x(2),x(3)], U31wv,'UniformOutput',false));
U32w = cell2mat(cellfun(@(x) [x(1),x(2),x(3)], U32wv,'UniformOutput',false));
U33w = cell2mat(cellfun(@(x) [x(1),x(2),x(3)], U33wv,'UniformOutput',false));
U3w = cell2mat(cellfun(@(x) [x(1),x(2),x(3)], U3wv,'UniformOutput',false));

%%%%%%%% Duration %%%%%%%%
% Vowel durations. L.voweldur is not of uniform length,
% and the vowels need to count from the end. This is
% adjusted by the anonymous function.
% We assume L.voweldur has vowel lengths in time order.
U31d = cell2mat(cellfun(@(x) [x(length(x)),x(length(x)-1),x(length(x)-2)], L.voweldur(U31)','UniformOutput',false));
U32d = cell2mat(cellfun(@(x) [x(length(x)),x(length(x)-1),x(length(x)-2)], L.voweldur(U32)','UniformOutput',false));
U33d = cell2mat(cellfun(@(x) [x(length(x)),x(length(x)-1),x(length(x)-2)], L.voweldur(U33)','UniformOutput',false));
U3d = cell2mat(cellfun(@(x) [x(length(x)),x(length(x)-1),x(length(x)-2)], L.voweldur(U3)','UniformOutput',false));

% Feature matrix, with six colums. Row indices are items.
X = [U3w,U3d];


% 1 indicating final stress
% 2 penultimate stress
% 3 antepenultimate stress.  
Y = U31 + U32 * 2 + U33 * 3;
Y = Y(U3);


% Save the data
R.X = X;
R.Y = Y;

dim = length(X(:,1));
R.dim = dim;

% Fit 3-class svm using just weights, just durations
% and both. Durations help a bit.

R.svm1 = fitcecoc(X(:,1:3),Y); % Cepstral weight
R.svm2 = fitcecoc(X(:,4:6),Y); % Duration
R.svm3 = fitcecoc(X,Y);        % Both



% Evaluate on training data.
% resubLoss(R.svm1) % 0.0626  weights
% resubLoss(R.svm2) % 0.2101  durations
% resubLoss(R.svm3) % 0.0507  both
disp(1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Crossvalidate following
%  https://www.mathworks.com/help/stats/fitcecoc.html.

% Template
t1 = templateSVM('Standardize',1);
t2 = templateSVM('Standardize',1);
t3 = templateSVM('Standardize',1);

% Train the ECOC classifier

%mdl1 = fitcecoc(X(:,1:3),Y,'Learners',t1);
%mdl2 = fitcecoc(X(:,4:6),Y,'Learners',t2);
%mdl3 = fitcecoc(X,Y,'Learners',t3);

% Thu Nov 22 09:29:01 EST 2018
% The prior can be 'empirical' (default) or 'uniform', see https://www.mathworks.com/help/stats/fitcecoc.html
R.mdl1 = fitcecoc(X(:,1:3),Y,'Learners',t1,'Prior','empirical');
R.mdl2 = fitcecoc(X(:,4:6),Y,'Learners',t2,'Prior','empirical');
R.mdl3 = fitcecoc(X,Y,'Learners',t3,'Prior','empirical');

% Cross-validate Mdl using 10-fold cross-validation.

R.cmdl1 = crossval(R.mdl1);
R.cmdl2 = crossval(R.mdl2);
R.cmdl3 = crossval(R.mdl3);

% The following values were obtained on Jan 2, 2024
%                           basic   uniform
R.loss1 = kfoldLoss(R.cmdl1) %  0.0556  0.0753
R.loss2 = kfoldLoss(R.cmdl2) %  0.2101  0.3465
R.loss3 = kfoldLoss(R.cmdl3) %  0.0461  0.0582

% What is the major-class baseline? Is basic weight-only any better?

% Save R
% To see R,
%   load('/local/matlab/bpstress/bpw2_classify3c1.mat')
save(savename,'R');

disp(1);

% Parse a line into a key and a vector of int.
function [key,a] = parse_alignment(line)
    key = sscanf(line,'%s',1);
    [~,klen] =  size(key);
    [~,llen] = size(line);
    line = line((klen+1):llen);
    a = sscanf(line,'%d')';
end

% Parse a line from the table.
% The input line looks like this.
% f58br08b11k1-s087-2	abacaxi	abacaxi_U411	4	1	1	4.45933 4.46457 4.43014 4.40614	5115.16 5122.39 5166.43 5153.47	362_364_3
% uid                   wf1     wf2             syl cit dec [w1] [w2]
%   bns04_st1921_trn 1 12 ; 6 7 ; 143 3 ; 50 8 ; 60 3 ; 143 4 ; 146 13
function [uid,word_form1,word_form2,syl_count,citation_stress,decode_stress,weight1,weight2] = parse_line(line)
    part = strsplit(line,'\t');
    uid = part{1};
    word_form1 = part{2};
    word_form2 = part{3};
    syl_count = str2num(part{4});
    citation_stress = str2num(part{5});
    decode_stress = str2num(part{6});
    weight1 = str2num(part{7});
    weight2 = str2num(part{8});
end

% Result of 'OptimizeHyperparameters','all'
% Best estimated feasible point (according to models):
%    BoxConstraint    KernelScale    KernelFunction    PolynomialOrder    Standardize
%    _____________    ___________    ______________    _______________    ___________
%
%       6.9424            NaN          polynomial             2              true    
%
%Estimated objective function value = 0.082355
%Estimated function evaluation time = 0.48633

% 0.0846 weight
% 0.3035 duration
% 0.0871 bothREPLACE_WITH_DASH_DASHit's a bit worse

end


##### SOURCE END #####
-->
</body>
</html>
